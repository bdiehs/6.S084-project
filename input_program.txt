import leon.annotation._
import leon.lang._
import leon.lang.synthesis._

object Complete {
  sealed abstract class List
  case class Cons(head: BigInt, tail: List) extends List
  case object Nil extends List

  def size(l: List) : BigInt = (l match {
    case Nil => BigInt(0)
    case Cons(_, t) => BigInt(1) + size(t)
  }) ensuring(res => res >= 0)

  def content(l: List): Set[BigInt] = l match {
    case Nil => Set.empty[BigInt]
    case Cons(i, t) => Set(i) ++ content(t)
  }


  def split (lst : List) : (List, List) = {
    choose {(res : (List, List)) =>
      if (lst == Nil) {
        res == ((Nil, Nil))
      } else {
        if (lst == Cons(BigInt(0), Nil)) {
          res == ((Cons(BigInt(0), Nil), Nil))
        } else {
          if (lst == (Cons(BigInt(0), Cons(BigInt(1), Nil)))) { 
            res == ((Cons(BigInt(0), Nil), Cons(BigInt(1), Nil)))
          } else {
            if (lst == (Cons(BigInt(0), Cons(BigInt(1), Cons(BigInt(2), Nil))))) { 
            res == ((Cons(BigInt(0), Cons(BigInt(2), Nil)), Cons(BigInt(1), Nil)))
           } else 
             if (lst == (Cons(BigInt(0), Cons(BigInt(1), Cons(BigInt(2), Cons(BigInt(3), Nil)))))) {
               res == ((Cons(BigInt(0), Cons(BigInt(2), Nil))), (Cons(BigInt(1), Cons(BigInt(3), Nil))))
             } else {
               true 
             }
          }
        }
      }


    //lst match { 
    //  case Nil => (res) == ((Nil, Nil))
    //  case Cons(BigInt(0), Nil) => (res) == ((Cons(BigInt(0), Nil), Nil))
    //  case Cons(BigInt(0), Cons(BigInt(1), Nil)) => (res) == ((Cons(BigInt(0), Nil), Cons(BigInt(1), Nil)))
    //  case _ => true
    //}
    }
  } 
}
